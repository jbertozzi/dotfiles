# functions kubeon/kubeoff
kubeon() {
  if [[ -w ~/.config/starship.toml ]]; then
    tomcli-set ~/.config/starship.toml false kubernetes.disabled
    tomcli-set ~/.config/starship.toml del kubernetes.detect_folders
  fi
}

kubeoff() {
  if [[ -w ~/.config/starship.toml ]]; then
    tomcli-set ~/.config/starship.toml true kubernetes.disabled
    tomcli-set ~/.config/starship.toml list kubernetes.detect_folders 'vars'
  fi
}

vaulton() {
  if [[ -w ~/.config/starship.toml ]]; then
    tomcli-set ~/.config/starship.toml false env_var.VAULT_ADDR.disabled
  fi
}

vaultoff() {
  if [[ -w ~/.config/starship.toml ]]; then
    tomcli-set ~/.config/starship.toml true env_var.VAULT_ADDR.disabled
  fi
}

# fonction e() → secrets
function e() {
  local secrets="$HOME/.secrets.json.gpg"
  local json env choice executed verbose=0
  local -A vars

  # handle options
  while getopts "v" opt; do
    case $opt in
      v) verbose=1 ;;
    esac
  done
  shift $((OPTIND - 1))

  # graceful exit on Ctrl-C or ESC
  trap 'echo "\n[interrupted] no changes made."; return 1' INT TERM

  if [[ ! -f $secrets ]]; then
    print "'$secrets' not found"
    return 1
  fi

  # decrypt the JSON secrets file
  json=$(gpg --quiet --decrypt "$secrets" 2>/dev/null)
  if [[ $? -ne 0 || -z "$json" ]]; then
    print "Error: failed to decrypt $secrets"
    return 1
  fi

  # if no argument → interactive selection
  if (( $# == 0 )); then
    env=$(jq -r '. | keys[]' <<<"$json" | fzf)
    [[ -z $env ]] && { echo "Cancelled."; return 0 }

    choice=$(jq -r --arg env "$env" '.[$env] | keys[]' <<<"$json" | fzf)
    [[ -z $choice ]] && { echo "Cancelled."; return 0 }

    # extract the selected dictionary and format as key=value pairs
    while IFS='=' read -r k v; do
      [[ -n $k ]] && vars[$k]=$v
    done < <(jq -r --arg env "$env" --arg choice "$choice" \
      '.[$env][$choice] | to_entries[] | "\(.key)=\(.value)"' <<<"$json")

  else
    # e toto.tata or e prod/db works
    local keys=".$*"
    keys="${keys//\//.}"  # allow '/' as a separator (default is '.')
    while IFS='=' read -r k v; do
      [[ -n $k ]] && vars[$k]=$v
    done < <(jq -r "$keys | to_entries[] | \"\(.key)=\(.value)\"" <<<"$json")
  fi

  # for each key, we export the variable, unless the key is 'cmd' in which 
  # case we execute a command (useful for ssh port forwarding for example)
  local key
  for key in ${(k)vars}; do
    if [[ "$key" == "cmd" ]]; then
      eval "${vars[$key]}"
      if [[ $? -eq 0 ]]; then
        print "command executed: ${vars[$key]}" >&2
      else
        print "command failed: ${vars[$key]}" >&2
      fi
    else
      export "$key=${vars[$key]}"
      if (( verbose )); then
        print "environment set: $key=${vars[$key]}" >&2
      else
        print "environment set: $key" >&2
      fi
    fi
  done
}

# Widget personnalisé pour navigation complétion
function down-or-complete() {
  if [[ $WIDGET == *menu* ]]; then
    zle .down-line-or-history
  else
    zle expand-or-complete
  fi
}
zle -N down-or-complete

function up-or-complete() {
  if [[ $WIDGET == *menu* ]]; then
    zle .up-line-or-history
  else
    zle expand-or-complete
  fi
}
zle -N up-or-complete
